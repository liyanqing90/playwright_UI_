# 插件系统开发指南

## 概述

本项目的插件系统为命令注册机制提供了强大的扩展能力，允许开发者创建自定义命令插件，无需修改核心代码即可扩展系统功能。

## 插件系统架构

### 核心组件

```
插件系统架构
├── PluginManager          # 插件管理器
│   ├── 插件发现
│   ├── 插件加载/卸载
│   ├── 插件启用/禁用
│   └── 插件信息管理
├── CommandRegistry         # 命令注册中心
│   ├── 插件命令注册
│   ├── 命令查询
│   └── 命令执行
└── Plugin Interface        # 插件接口
    ├── 插件元数据
    ├── 生命周期函数
    └── 命令实现
```

### 插件生命周期

1. **发现阶段**：扫描插件目录，识别插件文件
2. **加载阶段**：导入插件模块，验证插件格式
3. **初始化阶段**：调用插件初始化函数，注册命令
4. **运行阶段**：插件命令可被调用执行
5. **卸载阶段**：调用清理函数，注销命令，释放资源

## 插件开发指南

### 1. 插件文件结构

一个标准的插件文件应包含以下组件：

```python
# 插件元数据
PLUGIN_INFO = {
    'name': 'PluginName',
    'version': '1.0.0',
    'description': 'Plugin description',
    'author': 'Author Name',
    'commands': ['command1', 'command2']  # 插件提供的命令列表
}

# 命令实现类
@CommandRegistry.register('command_name')
class CustomCommand(Command):
    # 命令实现
    pass

# 生命周期函数
def initialize_plugin():
    # 插件初始化逻辑
    return PLUGIN_INFO

def cleanup_plugin():
    # 插件清理逻辑
    pass

def validate_plugin_config(config):
    # 配置验证逻辑
    return True

def get_plugin_info():
    # 获取插件信息
    return PLUGIN_INFO.copy()
```

### 2. 插件元数据规范

```python
PLUGIN_INFO = {
    'name': str,           # 插件名称（必需，唯一标识）
    'version': str,        # 版本号（必需，建议使用语义化版本）
    'description': str,    # 插件描述（必需）
    'author': str,         # 作者信息（必需）
    'email': str,          # 联系邮箱（可选）
    'url': str,            # 项目主页（可选）
    'license': str,        # 许可证（可选）
    'commands': List[str], # 提供的命令列表（必需）
    'dependencies': List[str], # 依赖的其他插件（可选）
    'min_core_version': str,   # 最小核心版本要求（可选）
    'max_core_version': str,   # 最大核心版本要求（可选）
    'tags': List[str],     # 插件标签（可选）
    'category': str,       # 插件分类（可选）
}
```

### 3. 命令实现规范

#### 基本命令结构

```python
from src.automation.commands.base_command import Command, CommandRegistry
from typing import Dict, Any
import logging

logger = logging.getLogger(__name__)

@CommandRegistry.register('custom_command')
class CustomCommand(Command):
    """自定义命令示例"""
    
    def validate_args(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> bool:
        """参数验证
        
        Args:
            ui_helper: UI操作助手
            selector: 元素选择器
            value: 命令值
            step: 步骤配置
            
        Returns:
            bool: 验证是否通过
        """
        # 实现参数验证逻辑
        if not value:
            logger.error("Command value is required")
            return False
        return True
    
    def before_execute(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> None:
        """执行前钩子"""
        logger.info(f"Preparing to execute custom command with value: {value}")
        # 执行前的准备工作
    
    def execute(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> Any:
        """命令执行逻辑
        
        Args:
            ui_helper: UI操作助手
            selector: 元素选择器
            value: 命令值
            step: 步骤配置
            
        Returns:
            Any: 执行结果
        """
        self.before_execute(ui_helper, selector, value, step)
        
        try:
            # 实现具体的命令逻辑
            result = self._perform_custom_action(ui_helper, selector, value, step)
            
            self.after_execute(result, ui_helper, selector, value, step)
            return result
            
        except Exception as e:
            self.on_error(e, ui_helper, selector, value, step)
            raise
    
    def after_execute(self, result: Any, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> None:
        """执行后钩子"""
        logger.info(f"Custom command executed successfully: {result}")
        # 执行后的清理工作
    
    def on_error(self, error: Exception, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> None:
        """错误处理钩子"""
        logger.error(f"Custom command failed: {error}")
        # 错误处理逻辑
    
    def _perform_custom_action(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> Any:
        """私有方法：实现具体的操作逻辑"""
        # 具体的实现逻辑
        return f"Executed custom action with {value}"
```

#### 异步命令支持

```python
@CommandRegistry.register('async_custom_command')
class AsyncCustomCommand(Command):
    """异步自定义命令"""
    
    async def execute_async(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> Any:
        """异步执行方法"""
        await self.before_execute_async(ui_helper, selector, value, step)
        
        try:
            # 异步操作逻辑
            import asyncio
            await asyncio.sleep(1)  # 模拟异步操作
            result = f"Async result: {value}"
            
            await self.after_execute_async(result, ui_helper, selector, value, step)
            return result
            
        except Exception as e:
            await self.on_error_async(e, ui_helper, selector, value, step)
            raise
```

### 4. 生命周期函数实现

#### 初始化函数

```python
def initialize_plugin():
    """插件初始化函数
    
    在插件加载时调用，用于：
    - 设置插件配置
    - 注册事件监听器
    - 初始化资源
    - 验证依赖
    
    Returns:
        dict: 插件信息
    """
    logger.info(f"Initializing plugin: {PLUGIN_INFO['name']} v{PLUGIN_INFO['version']}")
    
    # 检查依赖
    dependencies = PLUGIN_INFO.get('dependencies', [])
    for dep in dependencies:
        if not _check_dependency(dep):
            raise RuntimeError(f"Missing dependency: {dep}")
    
    # 设置默认配置
    _setup_default_config()
    
    # 注册事件监听器
    _register_event_listeners()
    
    logger.info(f"Plugin {PLUGIN_INFO['name']} initialized successfully")
    return PLUGIN_INFO

def _check_dependency(dependency_name: str) -> bool:
    """检查依赖是否满足"""
    try:
        # 检查依赖插件是否已加载
        from src.automation.commands.plugin_manager import PluginManager
        plugin_manager = PluginManager()
        loaded_plugins = plugin_manager.list_plugins()
        return dependency_name in loaded_plugins
    except Exception:
        return False

def _setup_default_config():
    """设置默认配置"""
    from src.automation.commands.command_config import command_config_manager
    
    # 为插件命令设置默认配置
    for command_name in PLUGIN_INFO['commands']:
        default_config = {
            'timeout': 30,
            'retry_count': 2,
            'enabled': True,
            'log_level': 'INFO'
        }
        command_config_manager.set_command_config(command_name, default_config)

def _register_event_listeners():
    """注册事件监听器"""
    from src.automation.commands.command_monitor import command_monitor
    
    def on_command_executed(command_name: str, result: Any):
        if command_name in PLUGIN_INFO['commands']:
            logger.debug(f"Plugin command {command_name} executed: {result}")
    
    command_monitor.add_listener('command_executed', on_command_executed)
```

#### 清理函数

```python
def cleanup_plugin():
    """插件清理函数
    
    在插件卸载时调用，用于：
    - 注销命令
    - 清理资源
    - 移除事件监听器
    - 保存状态
    """
    logger.info(f"Cleaning up plugin: {PLUGIN_INFO['name']}")
    
    # 注销命令
    _unregister_commands()
    
    # 移除事件监听器
    _remove_event_listeners()
    
    # 清理资源
    _cleanup_resources()
    
    logger.info(f"Plugin {PLUGIN_INFO['name']} cleaned up successfully")

def _unregister_commands():
    """注销插件命令"""
    from src.automation.commands.base_command import CommandRegistry
    
    for command_name in PLUGIN_INFO['commands']:
        try:
            CommandRegistry.unregister_command(command_name)
            logger.info(f"Unregistered command: {command_name}")
        except Exception as e:
            logger.error(f"Error unregistering command {command_name}: {e}")

def _remove_event_listeners():
    """移除事件监听器"""
    from src.automation.commands.command_monitor import command_monitor
    
    # 移除之前注册的监听器
    # 注意：这需要保存监听器引用
    pass

def _cleanup_resources():
    """清理插件资源"""
    # 关闭文件句柄
    # 断开网络连接
    # 清理临时文件
    # 等等
    pass
```

#### 配置验证函数

```python
def validate_plugin_config(config: Dict[str, Any]) -> bool:
    """验证插件配置
    
    Args:
        config: 插件配置字典
        
    Returns:
        bool: 配置是否有效
    """
    required_keys = ['enabled']
    optional_keys = ['log_level', 'timeout', 'retry_count']
    
    # 检查必需的配置项
    for key in required_keys:
        if key not in config:
            logger.error(f"Missing required config key: {key}")
            return False
    
    # 验证配置值
    if 'enabled' in config and not isinstance(config['enabled'], bool):
        logger.error("'enabled' must be a boolean value")
        return False
    
    if 'timeout' in config:
        try:
            timeout = float(config['timeout'])
            if timeout <= 0:
                logger.error("'timeout' must be a positive number")
                return False
        except (ValueError, TypeError):
            logger.error("'timeout' must be a number")
            return False
    
    if 'retry_count' in config:
        try:
            retry_count = int(config['retry_count'])
            if retry_count < 0:
                logger.error("'retry_count' must be a non-negative integer")
                return False
        except (ValueError, TypeError):
            logger.error("'retry_count' must be an integer")
            return False
    
    if 'log_level' in config:
        valid_levels = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
        if config['log_level'].upper() not in valid_levels:
            logger.error(f"'log_level' must be one of: {valid_levels}")
            return False
    
    return True
```

## 插件使用指南

### 1. 插件管理器使用

#### 基本操作

```python
from src.automation.commands.plugin_manager import PluginManager

# 创建插件管理器实例
plugin_manager = PluginManager()

# 发现插件
plugins = plugin_manager.discover_plugins('plugins')  # 扫描plugins目录
print(f"发现的插件: {[p['name'] for p in plugins]}")

# 加载插件
for plugin in plugins:
    success = plugin_manager.load_plugin(plugin['path'])
    print(f"插件 {plugin['name']} 加载{'成功' if success else '失败'}")

# 列出已加载的插件
loaded_plugins = plugin_manager.list_plugins()
print(f"已加载的插件: {list(loaded_plugins.keys())}")

# 获取插件信息
for plugin_name in loaded_plugins:
    info = plugin_manager.get_plugin_info(plugin_name)
    print(f"插件信息: {info}")

# 启用/禁用插件
plugin_manager.enable_plugin('plugin_name')
plugin_manager.disable_plugin('plugin_name')

# 卸载插件
plugin_manager.unload_plugin('plugin_name')
```

#### 批量操作

```python
# 批量加载插件目录中的所有插件
def load_all_plugins(plugin_dir: str):
    plugin_manager = PluginManager()
    plugins = plugin_manager.discover_plugins(plugin_dir)
    
    loaded_count = 0
    for plugin in plugins:
        try:
            if plugin_manager.load_plugin(plugin['path']):
                loaded_count += 1
                print(f"✓ 已加载: {plugin['name']}")
            else:
                print(f"✗ 加载失败: {plugin['name']}")
        except Exception as e:
            print(f"✗ 加载错误: {plugin['name']} - {e}")
    
    print(f"\n总计加载 {loaded_count}/{len(plugins)} 个插件")
    return loaded_count

# 使用示例
load_all_plugins('plugins')
```

### 2. 插件配置管理

```python
from src.automation.commands.command_config import command_config_manager

# 为插件命令设置配置
command_config_manager.set_command_config('custom_wait', {
    'timeout': 60,
    'retry_count': 3,
    'enabled': True,
    'log_level': 'DEBUG',
    'custom_param': 'value'
})

# 获取插件命令配置
config = command_config_manager.get_command_config('custom_wait')
print(f"插件命令配置: {config}")

# 批量配置插件命令
plugin_commands = ['custom_wait', 'custom_log', 'custom_random']
for cmd in plugin_commands:
    command_config_manager.set_command_config(cmd, {
        'timeout': 30,
        'enabled': True
    })
```

### 3. 插件命令执行

```python
from src.automation.commands.command_executor import CommandExecutor
from src.automation.commands.base_command import CommandRegistry

# 确保插件已加载
CommandRegistry.auto_discover_commands('src.automation.commands')

# 使用执行器执行插件命令
executor = CommandExecutor()

# 执行自定义等待命令
step = {
    'action': 'custom_wait',
    'wait_time': 2.0,
    'reason': '等待页面加载'
}

result = executor.execute_command(
    command_name='custom_wait',
    ui_helper=None,  # 根据实际情况传入
    selector='',
    value=step['wait_time'],
    step=step
)
print(f"执行结果: {result}")

# 批量执行插件命令
steps = [
    {'action': 'custom_log', 'message': '开始测试', 'level': 'info'},
    {'action': 'custom_wait', 'wait_time': 1.0, 'reason': '短暂等待'},
    {'action': 'custom_random', 'type': 'number', 'min': 1, 'max': 10}
]

results = executor.execute_batch(
    steps=steps,
    ui_helper=None,
    parallel=False
)
print(f"批量执行结果: {results}")
```

### 4. 插件监控

```python
from src.automation.commands.command_monitor import command_monitor

# 启用监控
command_monitor.enable()

# 为插件命令设置监控阈值
command_monitor.set_threshold('custom_wait', 'execution_time', 5.0)
command_monitor.set_threshold('custom_log', 'error_rate', 0.05)

# 添加插件特定的监控监听器
def on_plugin_command_slow(command_name: str, metric: str, value: float, threshold: float):
    if command_name.startswith('custom_'):
        print(f"⚠️ 插件命令执行缓慢: {command_name} - {value:.2f}s (阈值: {threshold}s)")

command_monitor.add_listener('threshold_exceeded', on_plugin_command_slow)

# 生成插件命令监控报告
report = command_monitor.generate_report()
plugin_report = {k: v for k, v in report.items() if k.startswith('custom_')}
print(f"插件命令监控报告: {plugin_report}")
```

## 插件开发最佳实践

### 1. 命名规范

- **插件名称**：使用 PascalCase，如 `CustomCommandPlugin`
- **命令名称**：使用 snake_case，如 `custom_wait`
- **文件名称**：使用 snake_case，如 `custom_command_plugin.py`
- **类名称**：使用 PascalCase + Command 后缀，如 `CustomWaitCommand`

### 2. 错误处理

```python
@CommandRegistry.register('safe_command')
class SafeCommand(Command):
    def execute(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]):
        try:
            # 命令逻辑
            return self._safe_operation(value)
        except ValueError as e:
            # 参数错误
            logger.error(f"Invalid parameter: {e}")
            raise
        except TimeoutError as e:
            # 超时错误
            logger.warning(f"Operation timeout: {e}")
            return None
        except Exception as e:
            # 其他错误
            logger.error(f"Unexpected error: {e}", exc_info=True)
            raise RuntimeError(f"Command failed: {e}") from e
    
    def _safe_operation(self, value):
        # 安全的操作实现
        if not value:
            raise ValueError("Value cannot be empty")
        return f"Processed: {value}"
```

### 3. 日志记录

```python
import logging

# 为插件创建专用的日志记录器
logger = logging.getLogger(f"plugin.{PLUGIN_INFO['name']}")

@CommandRegistry.register('logged_command')
class LoggedCommand(Command):
    def execute(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]):
        # 记录执行开始
        logger.info(f"Executing {self.__class__.__name__} with value: {value}")
        
        try:
            result = self._perform_operation(value)
            
            # 记录成功
            logger.info(f"Command executed successfully: {result}")
            return result
            
        except Exception as e:
            # 记录错误
            logger.error(f"Command execution failed: {e}", exc_info=True)
            raise
    
    def _perform_operation(self, value):
        # 详细的操作日志
        logger.debug(f"Starting operation with value: {value}")
        
        # 模拟操作步骤
        logger.debug("Step 1: Validating input")
        if not value:
            raise ValueError("Invalid input")
        
        logger.debug("Step 2: Processing data")
        result = f"Processed: {value}"
        
        logger.debug(f"Step 3: Operation completed with result: {result}")
        return result
```

### 4. 配置管理

```python
# 插件配置模板
DEFAULT_CONFIG = {
    'timeout': 30,
    'retry_count': 2,
    'enabled': True,
    'log_level': 'INFO',
    'custom_settings': {
        'max_items': 100,
        'batch_size': 10,
        'use_cache': True
    }
}

@CommandRegistry.register('configurable_command')
class ConfigurableCommand(Command):
    def __init__(self):
        super().__init__()
        self.config = self._load_config()
    
    def _load_config(self):
        """加载命令配置"""
        from src.automation.commands.command_config import command_config_manager
        
        config = command_config_manager.get_command_config('configurable_command')
        if not config:
            # 使用默认配置
            config = DEFAULT_CONFIG.copy()
            command_config_manager.set_command_config('configurable_command', config)
        
        return config
    
    def execute(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]):
        # 使用配置
        max_items = self.config.get('custom_settings', {}).get('max_items', 100)
        batch_size = self.config.get('custom_settings', {}).get('batch_size', 10)
        
        logger.info(f"Processing with max_items={max_items}, batch_size={batch_size}")
        
        # 实现逻辑
        return f"Processed {value} with config"
```

### 5. 测试支持

```python
# 插件测试工具
def test_plugin_commands():
    """测试插件命令"""
    from src.automation.commands.base_command import CommandRegistry
    
    # 注册插件命令
    CommandRegistry.auto_discover_commands(__name__)
    
    # 测试命令注册
    for command_name in PLUGIN_INFO['commands']:
        command = CommandRegistry.get_command(command_name)
        assert command is not None, f"Command {command_name} not registered"
        print(f"✓ Command {command_name} registered successfully")
    
    # 测试命令执行
    test_cases = [
        {'command': 'custom_wait', 'value': 1.0, 'expected': True},
        {'command': 'custom_log', 'value': 'test message', 'expected': True},
        {'command': 'custom_random', 'value': None, 'expected': True}
    ]
    
    for case in test_cases:
        try:
            command = CommandRegistry.get_command(case['command'])
            result = command.execute(None, '', case['value'], {})
            print(f"✓ Command {case['command']} executed: {result}")
        except Exception as e:
            print(f"✗ Command {case['command']} failed: {e}")

if __name__ == '__main__':
    test_plugin_commands()
```

## 插件部署和分发

### 1. 插件打包

```python
# setup.py for plugin distribution
from setuptools import setup, find_packages

setup(
    name="custom-command-plugin",
    version="1.0.0",
    description="Custom command plugin for automation framework",
    author="Plugin Developer",
    author_email="developer@example.com",
    packages=find_packages(),
    install_requires=[
        # 插件依赖
    ],
    entry_points={
        'automation_plugins': [
            'custom_commands = custom_command_plugin:initialize_plugin',
        ],
    },
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3.8+",
    ],
)
```

### 2. 插件安装

```bash
# 从本地安装
pip install -e /path/to/plugin

# 从 PyPI 安装
pip install custom-command-plugin

# 从 Git 仓库安装
pip install git+https://github.com/user/custom-command-plugin.git
```

### 3. 插件配置文件

```json
{
  "name": "CustomCommandPlugin",
  "version": "1.0.0",
  "enabled": true,
  "config": {
    "timeout": 30,
    "retry_count": 2,
    "custom_settings": {
      "max_items": 100,
      "batch_size": 10
    }
  },
  "commands": {
    "custom_wait": {
      "enabled": true,
      "timeout": 60
    },
    "custom_log": {
      "enabled": true,
      "log_level": "INFO"
    }
  }
}
```

## 故障排除

### 常见问题

1. **插件加载失败**
    - 检查插件文件格式
    - 验证 PLUGIN_INFO 是否正确定义
    - 确保所有必需的函数都已实现

2. **命令注册失败**
    - 检查装饰器语法
    - 确保命令名称唯一
    - 验证命令类继承自 Command

3. **插件依赖问题**
    - 检查依赖插件是否已加载
    - 验证版本兼容性
    - 确保所需的 Python 包已安装

4. **配置问题**
    - 验证配置文件格式
    - 检查配置验证函数
    - 确保配置键名正确

### 调试技巧

```python
# 启用插件调试日志
import logging
logging.getLogger('plugin').setLevel(logging.DEBUG)

# 检查插件状态
def debug_plugin_status(plugin_name: str):
    from src.automation.commands.plugin_manager import PluginManager
    
    plugin_manager = PluginManager()
    
    # 检查插件是否已加载
    loaded_plugins = plugin_manager.list_plugins()
    if plugin_name in loaded_plugins:
        print(f"✓ 插件 {plugin_name} 已加载")
        
        # 获取插件信息
        info = plugin_manager.get_plugin_info(plugin_name)
        print(f"插件信息: {info}")
        
        # 检查插件命令
        from src.automation.commands.base_command import CommandRegistry
        commands = CommandRegistry.list_commands()
        plugin_commands = [cmd for cmd in info.get('commands', []) if cmd in commands]
        print(f"已注册的插件命令: {plugin_commands}")
        
    else:
        print(f"✗ 插件 {plugin_name} 未加载")
        
        # 尝试发现插件
        discovered = plugin_manager.discover_plugins('plugins')
        matching = [p for p in discovered if p['name'] == plugin_name]
        if matching:
            print(f"发现插件文件: {matching[0]['path']}")
        else:
            print(f"未发现插件文件")

# 使用示例
debug_plugin_status('CustomCommandPlugin')
```

## 总结

插件系统为自动化框架提供了强大的扩展能力，通过标准化的接口和完善的管理机制，开发者可以轻松创建和部署自定义命令插件。遵循本指南的最佳实践，可以确保插件的质量、可维护性和兼容性。

### 关键要点

1. **标准化接口**：遵循插件接口规范，确保兼容性
2. **生命周期管理**：正确实现初始化和清理函数
3. **错误处理**：完善的异常处理和日志记录
4. **配置管理**：灵活的配置系统支持
5. **测试验证**：充分的测试确保插件质量
6. **文档完善**：详细的使用说明和示例

通过插件系统，可以实现功能的模块化扩展，提高代码的可维护性和可重用性，为自动化测试框架提供更强大的能力。