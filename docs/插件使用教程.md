# 插件使用教程

## 快速开始

本教程将指导您如何在自动化测试框架中使用插件系统，包括加载现有插件、创建自定义插件以及管理插件配置。

## 第一步：了解插件系统

### 什么是插件？

插件是扩展自动化框架功能的独立模块，可以添加新的命令类型而无需修改核心代码。每个插件可以包含一个或多个自定义命令。

### 插件的优势

- **模块化**：功能独立，易于维护
- **可扩展**：无需修改核心代码即可添加新功能
- **可重用**：插件可以在不同项目间共享
- **热插拔**：支持运行时加载和卸载

## 第二步：使用现有插件

### 2.1 查看可用插件

```python
from src.automation.commands.plugin_manager import PluginManager

# 创建插件管理器
plugin_manager = PluginManager()

# 发现插件目录中的所有插件
plugins = plugin_manager.discover_plugins('plugins')
print("可用插件:")
for plugin in plugins:
    print(f"- {plugin['name']} v{plugin['version']}: {plugin['description']}")
```

### 2.2 加载插件

```python
# 加载单个插件
success = plugin_manager.load_plugin('plugins/custom_command_plugin.py')
if success:
    print("插件加载成功")
else:
    print("插件加载失败")

# 批量加载所有插件
def load_all_plugins():
    plugins = plugin_manager.discover_plugins('plugins')
    loaded_count = 0
    
    for plugin in plugins:
        try:
            if plugin_manager.load_plugin(plugin['path']):
                print(f"✓ 已加载: {plugin['name']}")
                loaded_count += 1
            else:
                print(f"✗ 加载失败: {plugin['name']}")
        except Exception as e:
            print(f"✗ 加载错误: {plugin['name']} - {e}")
    
    print(f"\n成功加载 {loaded_count}/{len(plugins)} 个插件")
    return loaded_count

load_all_plugins()
```

### 2.3 查看已加载的插件

```python
# 列出所有已加载的插件
loaded_plugins = plugin_manager.list_plugins()
print("已加载的插件:")
for name, info in loaded_plugins.items():
    print(f"- {name}: {info['description']}")
    print(f"  版本: {info['version']}")
    print(f"  命令: {', '.join(info['commands'])}")
    print()
```

### 2.4 使用插件命令

```python
from src.automation.commands.command_executor import CommandExecutor
from src.automation.commands.base_command import CommandRegistry

# 确保命令已注册
CommandRegistry.auto_discover_commands('src.automation.commands')

# 创建执行器
executor = CommandExecutor()

# 使用插件提供的自定义等待命令
step = {
    'action': 'custom_wait',
    'wait_time': 3.0,
    'reason': '等待页面完全加载'
}

result = executor.execute_command(
    command_name='custom_wait',
    ui_helper=None,  # 实际使用时传入UI助手
    selector='',
    value=step['wait_time'],
    step=step
)
print(f"等待命令执行结果: {result}")

# 使用自定义日志命令
log_step = {
    'action': 'custom_log',
    'message': '这是一条自定义日志',
    'level': 'info',
    'category': 'test'
}

log_result = executor.execute_command(
    command_name='custom_log',
    ui_helper=None,
    selector='',
    value=log_step['message'],
    step=log_step
)
print(f"日志命令执行结果: {log_result}")
```

## 第三步：创建自定义插件

### 3.1 创建插件文件

创建文件 `plugins/my_custom_plugin.py`：

```python
"""我的自定义插件"""

from typing import Dict, Any
import logging
import time
import requests

from src.automation.commands.base_command import Command, CommandRegistry

logger = logging.getLogger(__name__)

# 插件元数据
PLUGIN_INFO = {
    'name': 'MyCustomPlugin',
    'version': '1.0.0',
    'description': '我的第一个自定义插件',
    'author': '您的姓名',
    'commands': ['http_request', 'data_generator', 'file_operation']
}


@CommandRegistry.register('http_request')
class HttpRequestCommand(Command):
    """HTTP请求命令"""
    
    def validate_args(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> bool:
        url = step.get('url', value)
        if not url:
            logger.error("URL is required for HTTP request")
            return False
        
        method = step.get('method', 'GET').upper()
        if method not in ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']:
            logger.error(f"Unsupported HTTP method: {method}")
            return False
        
        return True
    
    def execute(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> Dict[str, Any]:
        self.before_execute(ui_helper, selector, value, step)
        
        try:
            url = step.get('url', value)
            method = step.get('method', 'GET').upper()
            headers = step.get('headers', {})
            data = step.get('data')
            timeout = step.get('timeout', 30)
            
            logger.info(f"发送 {method} 请求到: {url}")
            
            response = requests.request(
                method=method,
                url=url,
                headers=headers,
                json=data if data else None,
                timeout=timeout
            )
            
            result = {
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'content': response.text,
                'json': response.json() if response.headers.get('content-type', '').startswith('application/json') else None,
                'success': 200 <= response.status_code < 300
            }
            
            logger.info(f"HTTP请求完成，状态码: {response.status_code}")
            
            self.after_execute(result, ui_helper, selector, value, step)
            return result
            
        except Exception as e:
            self.on_error(e, ui_helper, selector, value, step)
            raise


@CommandRegistry.register('data_generator')
class DataGeneratorCommand(Command):
    """数据生成命令"""
    
    def validate_args(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> bool:
        data_type = step.get('type', 'string')
        if data_type not in ['string', 'number', 'email', 'phone', 'name', 'address']:
            logger.error(f"Unsupported data type: {data_type}")
            return False
        return True
    
    def execute(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> str:
        self.before_execute(ui_helper, selector, value, step)
        
        try:
            data_type = step.get('type', 'string')
            length = step.get('length', 10)
            
            if data_type == 'string':
                import string
                import random
                result = ''.join(random.choices(string.ascii_letters + string.digits, k=length))
            
            elif data_type == 'number':
                import random
                min_val = step.get('min', 1)
                max_val = step.get('max', 1000)
                result = str(random.randint(min_val, max_val))
            
            elif data_type == 'email':
                import random
                import string
                username = ''.join(random.choices(string.ascii_lowercase, k=8))
                domain = random.choice(['gmail.com', 'yahoo.com', 'hotmail.com', 'example.com'])
                result = f"{username}@{domain}"
            
            elif data_type == 'phone':
                import random
                result = f"1{''.join([str(random.randint(0, 9)) for _ in range(10)])}"
            
            elif data_type == 'name':
                import random
                first_names = ['张', '李', '王', '刘', '陈', '杨', '赵', '黄', '周', '吴']
                last_names = ['伟', '芳', '娜', '敏', '静', '丽', '强', '磊', '军', '洋']
                result = random.choice(first_names) + random.choice(last_names)
            
            elif data_type == 'address':
                import random
                cities = ['北京市', '上海市', '广州市', '深圳市', '杭州市', '南京市']
                districts = ['朝阳区', '海淀区', '西城区', '东城区', '丰台区', '石景山区']
                streets = ['中山路', '人民路', '建设路', '解放路', '和平路', '胜利路']
                result = f"{random.choice(cities)}{random.choice(districts)}{random.choice(streets)}{random.randint(1, 999)}号"
            
            else:
                result = "unknown"
            
            logger.info(f"生成 {data_type} 类型数据: {result}")
            
            # 可选：将结果存储到变量中
            var_name = step.get('store_in')
            if var_name and hasattr(ui_helper, 'set_variable'):
                ui_helper.set_variable(var_name, result)
                logger.info(f"数据已存储到变量: {var_name} = {result}")
            
            self.after_execute(result, ui_helper, selector, value, step)
            return result
            
        except Exception as e:
            self.on_error(e, ui_helper, selector, value, step)
            raise


@CommandRegistry.register('file_operation')
class FileOperationCommand(Command):
    """文件操作命令"""
    
    def validate_args(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> bool:
        operation = step.get('operation', 'read')
        if operation not in ['read', 'write', 'append', 'delete', 'exists']:
            logger.error(f"Unsupported file operation: {operation}")
            return False
        
        file_path = step.get('file_path', value)
        if not file_path:
            logger.error("File path is required")
            return False
        
        return True
    
    def execute(self, ui_helper, selector: str, value: Any, step: Dict[str, Any]) -> Any:
        self.before_execute(ui_helper, selector, value, step)
        
        try:
            import os
            
            operation = step.get('operation', 'read')
            file_path = step.get('file_path', value)
            content = step.get('content', '')
            encoding = step.get('encoding', 'utf-8')
            
            logger.info(f"执行文件操作: {operation} on {file_path}")
            
            if operation == 'read':
                with open(file_path, 'r', encoding=encoding) as f:
                    result = f.read()
                logger.info(f"读取文件成功，内容长度: {len(result)}")
            
            elif operation == 'write':
                with open(file_path, 'w', encoding=encoding) as f:
                    f.write(content)
                result = f"文件写入成功: {file_path}"
                logger.info(result)
            
            elif operation == 'append':
                with open(file_path, 'a', encoding=encoding) as f:
                    f.write(content)
                result = f"文件追加成功: {file_path}"
                logger.info(result)
            
            elif operation == 'delete':
                if os.path.exists(file_path):
                    os.remove(file_path)
                    result = f"文件删除成功: {file_path}"
                else:
                    result = f"文件不存在: {file_path}"
                logger.info(result)
            
            elif operation == 'exists':
                result = os.path.exists(file_path)
                logger.info(f"文件存在检查: {file_path} = {result}")
            
            else:
                raise ValueError(f"Unknown operation: {operation}")
            
            self.after_execute(result, ui_helper, selector, value, step)
            return result
            
        except Exception as e:
            self.on_error(e, ui_helper, selector, value, step)
            raise


# 插件生命周期函数
def initialize_plugin():
    """初始化插件"""
    logger.info(f"正在初始化插件: {PLUGIN_INFO['name']} v{PLUGIN_INFO['version']}")
    
    # 设置默认配置
    from src.automation.commands.command_config import command_config_manager
    
    for command_name in PLUGIN_INFO['commands']:
        default_config = {
            'timeout': 30,
            'retry_count': 2,
            'enabled': True,
            'log_level': 'INFO'
        }
        command_config_manager.set_command_config(command_name, default_config)
    
    logger.info(f"插件 {PLUGIN_INFO['name']} 初始化完成")
    return PLUGIN_INFO


def cleanup_plugin():
    """清理插件"""
    logger.info(f"正在清理插件: {PLUGIN_INFO['name']}")
    
    # 注销命令
    from src.automation.commands.base_command import CommandRegistry
    
    for command_name in PLUGIN_INFO['commands']:
        try:
            CommandRegistry.unregister_command(command_name)
            logger.info(f"已注销命令: {command_name}")
        except Exception as e:
            logger.error(f"注销命令失败 {command_name}: {e}")
    
    logger.info(f"插件 {PLUGIN_INFO['name']} 清理完成")


def validate_plugin_config(config: Dict[str, Any]) -> bool:
    """验证插件配置"""
    required_keys = ['enabled']
    
    for key in required_keys:
        if key not in config:
            logger.error(f"缺少必需的配置项: {key}")
            return False
    
    return True


def get_plugin_info() -> Dict[str, Any]:
    """获取插件信息"""
    return PLUGIN_INFO.copy()


if __name__ == '__main__':
    # 测试插件
    print(f"插件: {PLUGIN_INFO['name']}")
    print(f"版本: {PLUGIN_INFO['version']}")
    print(f"命令: {', '.join(PLUGIN_INFO['commands'])}")
```

### 3.2 测试自定义插件

创建测试文件 `test_my_plugin.py`：

```python
"""测试自定义插件"""

from src.automation.commands.plugin_manager import PluginManager
from src.automation.commands.command_executor import CommandExecutor
from src.automation.commands.base_command import CommandRegistry

def test_plugin():
    # 加载插件
    plugin_manager = PluginManager()
    success = plugin_manager.load_plugin('plugins/my_custom_plugin.py')
    
    if not success:
        print("插件加载失败")
        return
    
    print("插件加载成功")
    
    # 确保命令已注册
    CommandRegistry.auto_discover_commands('src.automation.commands')
    
    # 创建执行器
    executor = CommandExecutor()
    
    # 测试HTTP请求命令
    print("\n测试HTTP请求命令:")
    http_step = {
        'action': 'http_request',
        'url': 'https://httpbin.org/get',
        'method': 'GET',
        'timeout': 10
    }
    
    try:
        result = executor.execute_command(
            command_name='http_request',
            ui_helper=None,
            selector='',
            value=http_step['url'],
            step=http_step
        )
        print(f"HTTP请求结果: 状态码 {result['status_code']}")
    except Exception as e:
        print(f"HTTP请求失败: {e}")
    
    # 测试数据生成命令
    print("\n测试数据生成命令:")
    data_steps = [
        {'action': 'data_generator', 'type': 'email'},
        {'action': 'data_generator', 'type': 'phone'},
        {'action': 'data_generator', 'type': 'name'},
        {'action': 'data_generator', 'type': 'number', 'min': 100, 'max': 999}
    ]
    
    for step in data_steps:
        try:
            result = executor.execute_command(
                command_name='data_generator',
                ui_helper=None,
                selector='',
                value='',
                step=step
            )
            print(f"生成 {step['type']}: {result}")
        except Exception as e:
            print(f"数据生成失败 {step['type']}: {e}")
    
    # 测试文件操作命令
    print("\n测试文件操作命令:")
    test_file = 'test_output.txt'
    
    # 写入文件
    write_step = {
        'action': 'file_operation',
        'operation': 'write',
        'file_path': test_file,
        'content': '这是测试内容\n'
    }
    
    try:
        result = executor.execute_command(
            command_name='file_operation',
            ui_helper=None,
            selector='',
            value=test_file,
            step=write_step
        )
        print(f"文件写入: {result}")
    except Exception as e:
        print(f"文件写入失败: {e}")
    
    # 读取文件
    read_step = {
        'action': 'file_operation',
        'operation': 'read',
        'file_path': test_file
    }
    
    try:
        result = executor.execute_command(
            command_name='file_operation',
            ui_helper=None,
            selector='',
            value=test_file,
            step=read_step
        )
        print(f"文件内容: {result.strip()}")
    except Exception as e:
        print(f"文件读取失败: {e}")
    
    print("\n插件测试完成")

if __name__ == '__main__':
    test_plugin()
```

## 第四步：插件配置管理

### 4.1 设置插件配置

```python
from src.automation.commands.command_config import command_config_manager

# 为插件命令设置特定配置
command_config_manager.set_command_config('http_request', {
    'timeout': 60,  # HTTP请求超时时间
    'retry_count': 3,  # 重试次数
    'enabled': True,
    'log_level': 'INFO',
    'custom_headers': {  # 自定义配置
        'User-Agent': 'AutomationFramework/1.0'
    }
})

command_config_manager.set_command_config('data_generator', {
    'timeout': 10,
    'enabled': True,
    'default_length': 12,  # 默认生成长度
    'allowed_types': ['string', 'email', 'phone', 'name']  # 允许的数据类型
})

# 保存配置
command_config_manager.save_config()
print("插件配置已保存")
```

### 4.2 查看插件配置

```python
# 查看特定命令的配置
http_config = command_config_manager.get_command_config('http_request')
print(f"HTTP请求命令配置: {http_config}")

# 查看所有配置
all_configs = command_config_manager.get_all_configs()
print("所有命令配置:")
for cmd, config in all_configs.items():
    if cmd.startswith(('http_', 'data_', 'file_')):
        print(f"  {cmd}: {config}")
```

### 4.3 导出和导入配置

```python
# 导出配置到文件
command_config_manager.export_config('my_plugin_config.json')
print("配置已导出到 my_plugin_config.json")

# 从文件导入配置
command_config_manager.import_config('my_plugin_config.json')
print("配置已从 my_plugin_config.json 导入")
```

## 第五步：插件监控

### 5.1 启用插件监控

```python
from src.automation.commands.command_monitor import command_monitor

# 启用监控
command_monitor.enable()

# 为插件命令设置监控阈值
command_monitor.set_threshold('http_request', 'execution_time', 10.0)  # 10秒
command_monitor.set_threshold('http_request', 'error_rate', 0.1)       # 10%
command_monitor.set_threshold('data_generator', 'execution_time', 1.0)  # 1秒
command_monitor.set_threshold('file_operation', 'execution_time', 5.0)  # 5秒

print("插件监控已启用")
```

### 5.2 添加监控监听器

```python
# 添加插件特定的监控监听器
def on_plugin_performance_issue(command_name: str, metric: str, value: float, threshold: float):
    plugin_commands = ['http_request', 'data_generator', 'file_operation']
    if command_name in plugin_commands:
        print(f"⚠️ 插件性能警告: {command_name}")
        print(f"   指标: {metric}")
        print(f"   当前值: {value:.2f}")
        print(f"   阈值: {threshold:.2f}")
        
        # 可以在这里添加告警逻辑，如发送邮件、钉钉通知等

command_monitor.add_listener('threshold_exceeded', on_plugin_performance_issue)

def on_plugin_command_completed(command_name: str, execution_time: float, success: bool):
    plugin_commands = ['http_request', 'data_generator', 'file_operation']
    if command_name in plugin_commands:
        status = "成功" if success else "失败"
        print(f"📊 插件命令执行: {command_name} - {status} ({execution_time:.2f}s)")

command_monitor.add_listener('command_completed', on_plugin_command_completed)
```

### 5.3 查看监控报告

```python
# 生成监控报告
report = command_monitor.generate_report()

# 过滤插件命令的监控数据
plugin_commands = ['http_request', 'data_generator', 'file_operation']
plugin_report = {cmd: metrics for cmd, metrics in report.items() if cmd in plugin_commands}

print("插件命令监控报告:")
for command_name, metrics in plugin_report.items():
    print(f"\n{command_name}:")
    print(f"  执行次数: {metrics.get('execution_count', 0)}")
    print(f"  平均执行时间: {metrics.get('avg_execution_time', 0):.2f}s")
    print(f"  最大执行时间: {metrics.get('max_execution_time', 0):.2f}s")
    print(f"  错误率: {metrics.get('error_rate', 0):.2%}")
    print(f"  成功率: {metrics.get('success_rate', 0):.2%}")
```

## 第六步：在测试用例中使用插件

### 6.1 YAML测试用例示例

创建测试用例文件 `test_data/demo/cases/plugin_test.yaml`：

```yaml
name: "插件功能测试"
description: "测试自定义插件的各种命令"
steps:
  # 生成测试数据
  - action: data_generator
    type: email
    store_in: test_email
    description: "生成测试邮箱"
  
  - action: data_generator
    type: phone
    store_in: test_phone
    description: "生成测试电话"
  
  - action: data_generator
    type: name
    store_in: test_name
    description: "生成测试姓名"
  
  # 记录生成的数据
  - action: custom_log
    message: "生成的测试数据 - 邮箱: ${test_email}, 电话: ${test_phone}, 姓名: ${test_name}"
    level: info
    category: test_data
    description: "记录生成的测试数据"
  
  # 将数据写入文件
  - action: file_operation
    operation: write
    file_path: "test_output/generated_data.txt"
    content: "邮箱: ${test_email}\n电话: ${test_phone}\n姓名: ${test_name}\n"
    description: "保存测试数据到文件"
  
  # 发送HTTP请求验证邮箱格式
  - action: http_request
    url: "https://httpbin.org/post"
    method: POST
    headers:
      Content-Type: "application/json"
    data:
      email: "${test_email}"
      phone: "${test_phone}"
      name: "${test_name}"
    timeout: 30
    description: "发送HTTP请求验证数据"
  
  # 等待一段时间
  - action: custom_wait
    wait_time: 2
    reason: "等待处理完成"
    description: "等待处理"
  
  # 读取并验证文件内容
  - action: file_operation
    operation: read
    file_path: "test_output/generated_data.txt"
    store_in: file_content
    description: "读取保存的数据文件"
  
  # 记录文件内容
  - action: custom_log
    message: "文件内容: ${file_content}"
    level: info
    category: file_check
    description: "记录文件内容"
  
  # 清理测试文件
  - action: file_operation
    operation: delete
    file_path: "test_output/generated_data.txt"
    description: "清理测试文件"
```

### 6.2 Python测试脚本示例

创建测试脚本 `test_plugin_integration.py`：

```python
"""插件集成测试"""

import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.automation.commands.plugin_manager import PluginManager
from src.automation.commands.command_executor import CommandExecutor
from src.automation.commands.base_command import CommandRegistry
from src.automation.commands.command_monitor import command_monitor
from src.automation.commands.command_config import command_config_manager

def setup_plugins():
    """设置插件环境"""
    print("设置插件环境...")
    
    # 加载插件
    plugin_manager = PluginManager()
    plugins = plugin_manager.discover_plugins('plugins')
    
    for plugin in plugins:
        success = plugin_manager.load_plugin(plugin['path'])
        print(f"插件 {plugin['name']}: {'加载成功' if success else '加载失败'}")
    
    # 注册命令
    CommandRegistry.auto_discover_commands('src.automation.commands')
    
    # 启用监控
    command_monitor.enable()
    
    # 设置配置
    command_config_manager.set_global_config({
        'default_timeout': 30,
        'enable_monitoring': True,
        'log_level': 'INFO'
    })
    
    print("插件环境设置完成")

def run_plugin_test_suite():
    """运行插件测试套件"""
    print("\n开始插件测试套件...")
    
    executor = CommandExecutor()
    test_results = []
    
    # 测试用例1：数据生成和文件操作
    print("\n测试用例1：数据生成和文件操作")
    try:
        # 生成邮箱
        email = executor.execute_command('data_generator', None, '', '', {
            'type': 'email'
        })
        print(f"生成邮箱: {email}")
        
        # 写入文件
        write_result = executor.execute_command('file_operation', None, '', 'test_data.txt', {
            'operation': 'write',
            'content': f"测试邮箱: {email}\n"
        })
        print(f"文件写入: {write_result}")
        
        # 读取文件
        read_result = executor.execute_command('file_operation', None, '', 'test_data.txt', {
            'operation': 'read'
        })
        print(f"文件内容: {read_result.strip()}")
        
        # 删除文件
        delete_result = executor.execute_command('file_operation', None, '', 'test_data.txt', {
            'operation': 'delete'
        })
        print(f"文件删除: {delete_result}")
        
        test_results.append(('数据生成和文件操作', True, None))
        
    except Exception as e:
        print(f"测试失败: {e}")
        test_results.append(('数据生成和文件操作', False, str(e)))
    
    # 测试用例2：HTTP请求
    print("\n测试用例2：HTTP请求")
    try:
        http_result = executor.execute_command('http_request', None, '', 'https://httpbin.org/get', {
            'method': 'GET',
            'timeout': 10
        })
        print(f"HTTP请求状态: {http_result['status_code']}")
        print(f"请求成功: {http_result['success']}")
        
        test_results.append(('HTTP请求', http_result['success'], None))
        
    except Exception as e:
        print(f"HTTP请求失败: {e}")
        test_results.append(('HTTP请求', False, str(e)))
    
    # 测试用例3：批量数据生成
    print("\n测试用例3：批量数据生成")
    try:
        data_types = ['email', 'phone', 'name', 'number']
        generated_data = {}
        
        for data_type in data_types:
            step = {'type': data_type}
            if data_type == 'number':
                step.update({'min': 100, 'max': 999})
            
            result = executor.execute_command('data_generator', None, '', '', step)
            generated_data[data_type] = result
            print(f"生成 {data_type}: {result}")
        
        test_results.append(('批量数据生成', True, None))
        
    except Exception as e:
        print(f"批量数据生成失败: {e}")
        test_results.append(('批量数据生成', False, str(e)))
    
    # 输出测试结果
    print("\n=== 测试结果汇总 ===")
    passed = 0
    failed = 0
    
    for test_name, success, error in test_results:
        status = "✓ 通过" if success else "✗ 失败"
        print(f"{status}: {test_name}")
        if error:
            print(f"   错误: {error}")
        
        if success:
            passed += 1
        else:
            failed += 1
    
    print(f"\n总计: {passed + failed} 个测试，{passed} 个通过，{failed} 个失败")
    
    # 生成监控报告
    print("\n=== 性能监控报告 ===")
    report = command_monitor.generate_report()
    plugin_commands = ['http_request', 'data_generator', 'file_operation']
    
    for cmd in plugin_commands:
        if cmd in report:
            metrics = report[cmd]
            print(f"{cmd}:")
            print(f"  执行次数: {metrics.get('execution_count', 0)}")
            print(f"  平均时间: {metrics.get('avg_execution_time', 0):.3f}s")
            print(f"  成功率: {metrics.get('success_rate', 0):.1%}")
    
    return passed == len(test_results)

def main():
    """主函数"""
    print("插件集成测试")
    print("=" * 50)
    
    try:
        # 设置环境
        setup_plugins()
        
        # 运行测试
        success = run_plugin_test_suite()
        
        if success:
            print("\n🎉 所有测试通过！")
            return 0
        else:
            print("\n❌ 部分测试失败")
            return 1
            
    except Exception as e:
        print(f"\n💥 测试执行出错: {e}")
        import traceback
        traceback.print_exc()
        return 1

if __name__ == '__main__':
    exit_code = main()
    sys.exit(exit_code)
```

## 第七步：使用命令行工具管理插件

### 7.1 基本命令

```bash
# 列出所有可用命令（包括插件命令）
python -m src.automation.commands.command_cli list

# 查看特定插件命令的信息
python -m src.automation.commands.command_cli info http_request
python -m src.automation.commands.command_cli info data_generator

# 启用/禁用插件命令
python -m src.automation.commands.command_cli enable http_request
python -m src.automation.commands.command_cli disable file_operation
```

### 7.2 配置管理

```bash
# 查看插件命令配置
python -m src.automation.commands.command_cli config show http_request

# 设置插件命令配置
python -m src.automation.commands.command_cli config set http_request timeout 60
python -m src.automation.commands.command_cli config set data_generator enabled true

# 导出配置
python -m src.automation.commands.command_cli config export plugin_config.json

# 导入配置
python -m src.automation.commands.command_cli config import plugin_config.json
```

### 7.3 监控管理

```bash
# 生成监控报告
python -m src.automation.commands.command_cli monitor report

# 查看特定命令的监控指标
python -m src.automation.commands.command_cli monitor metrics http_request

# 重置监控数据
python -m src.automation.commands.command_cli monitor reset

# 启用/禁用监控
python -m src.automation.commands.command_cli monitor enable
python -m src.automation.commands.command_cli monitor disable
```

### 7.4 插件管理

```bash
# 列出已加载的插件
python -m src.automation.commands.command_cli plugin list

# 加载插件
python -m src.automation.commands.command_cli plugin load plugins/my_custom_plugin.py

# 卸载插件
python -m src.automation.commands.command_cli plugin unload MyCustomPlugin

# 启用/禁用插件
python -m src.automation.commands.command_cli plugin enable MyCustomPlugin
python -m src.automation.commands.command_cli plugin disable MyCustomPlugin
```

## 常见问题和解决方案

### Q1: 插件加载失败

**问题**：插件文件存在但加载失败

**解决方案**：
1. 检查插件文件语法是否正确
2. 确保 `PLUGIN_INFO` 字典格式正确
3. 验证所有必需的函数是否已实现
4. 查看错误日志获取详细信息

```python
# 调试插件加载
import logging
logging.basicConfig(level=logging.DEBUG)

plugin_manager = PluginManager()
success = plugin_manager.load_plugin('plugins/my_plugin.py')
if not success:
    print("检查日志获取详细错误信息")
```

### Q2: 插件命令未注册

**问题**：插件加载成功但命令无法使用

**解决方案**：
1. 确保使用了正确的装饰器：`@CommandRegistry.register('command_name')`
2. 检查命令名称是否与 `PLUGIN_INFO['commands']` 中的一致
3. 调用 `CommandRegistry.auto_discover_commands()` 重新发现命令

```python
# 检查命令注册状态
from src.automation.commands.base_command import CommandRegistry

commands = CommandRegistry.list_commands()
print(f"已注册的命令: {list(commands.keys())}")

# 检查特定命令
command = CommandRegistry.get_command('my_command')
if command:
    print(f"命令已注册: {command.__class__.__name__}")
else:
    print("命令未注册")
```

### Q3: 插件配置不生效

**问题**：设置了插件配置但不生效

**解决方案**：
1. 确保调用了 `command_config_manager.save_config()`
2. 检查配置键名是否正确
3. 验证插件是否正确读取配置

```python
# 检查配置状态
from src.automation.commands.command_config import command_config_manager

config = command_config_manager.get_command_config('my_command')
print(f"当前配置: {config}")

# 强制保存配置
command_config_manager.save_config()
print("配置已保存")
```

### Q4: 插件性能问题

**问题**：插件命令执行缓慢

**解决方案**：
1. 启用监控查看性能指标
2. 优化插件代码逻辑
3. 设置合适的超时时间
4. 使用异步执行（如果支持）

```python
# 启用性能监控
from src.automation.commands.command_monitor import command_monitor

command_monitor.enable()
command_monitor.set_threshold('my_command', 'execution_time', 5.0)

# 查看性能报告
report = command_monitor.generate_report()
if 'my_command' in report:
    metrics = report['my_command']
    print(f"平均执行时间: {metrics.get('avg_execution_time', 0):.2f}s")
```

## 总结

通过本教程，您已经学会了：

1. **使用现有插件**：发现、加载和使用插件
2. **创建自定义插件**：编写插件代码和测试
3. **配置管理**：设置和管理插件配置
4. **性能监控**：监控插件性能和设置告警
5. **集成测试**：在测试用例中使用插件
6. **命令行管理**：使用CLI工具管理插件
7. **故障排除**：解决常见问题

插件系统为自动化框架提供了强大的扩展能力，让您可以根据具体需求添加自定义功能，提高测试效率和覆盖范围。

### 下一步

- 探索更多插件开发模式
- 创建插件库和分享机制
- 集成第三方服务和API
- 开发专业领域的插件（如数据库操作、消息队列等）

祝您使用愉快！